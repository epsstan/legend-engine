
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::pure::lineage::scanProperties::*;
import meta::pure::lineage::scanRelations::*;
import meta::relational::authz::*;

// TODO - Move to different package or use a different model 
Class meta::relational::authz::User
{
   name: String[1];
   userName: String[1];
   dataClassification: Integer[1];
}

// TODO - Move to different package. Not relational
Class meta::relational::authz::AuthzResults
{
  aggregate: Boolean[1];
  results: Map<String, AuthzResult>[1];
}

Class meta::relational::authz::AuthzResult
{
  result: Boolean[1];
  reason: String[1];
}

function meta::relational::authz::newAuthzResults():AuthzResults[1]
{
  ^meta::relational::authz::AuthzResults(aggregate=false, results=newMap([]))
}

function meta::relational::authz::print(r: meta::relational::authz::AuthzResults[1]):Any[1]
{
  println('Aggregate authz result = ' + $r.aggregate->toString());
  $r.results->keyValues()->map(kv | println( 'Path : ' + $kv.first + ' => ' + $kv.second.result->toString() + ' : reason = ' + $kv.second.reason));
  1;
}

function meta::relational::authz::printAsString(r: meta::relational::authz::AuthzResults[1]):Any[1]
{
  let str1 = 'Aggregate authz result = ' + $r.aggregate->toString();
  let str2 = 
  fold( 
      $r.results->keyValues()->map(kv | 'Path : ' + $kv.first + ' => ' + $kv.second.result->toString() + ' : reason = ' + $kv.second.reason),
      {val, acc | $acc + $val + '\n'}, 
      ''
  );

  $str1 + '\n' + $str2;
}

function meta::relational::authz::add(results:meta::relational::authz::AuthzResults[1], path:String[1], result: meta::relational::authz::AuthzResult[1]):meta::relational::authz::AuthzResults[1]
{
  ^meta::relational::authz::AuthzResults(aggregate=$results.aggregate && $result.result, results=$results.results->put($path, $result));
}

function meta::relational::authz::merge(resultsList:meta::relational::authz::AuthzResults[0..*]):meta::relational::authz::AuthzResults[1]
{
  let mergedResults = fold($resultsList->map(r | $r.results), {val, acc| $acc->putAll($val)}, newMap([]));
  let mergedAggregate = !$mergedResults->values()->map(r | $r.result)->contains(false);
  ^meta::relational::authz::AuthzResults(aggregate=$mergedAggregate, results=$mergedResults);
}


function meta::relational::authz::isAuthorized(valueKey:String[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):AuthzResult[1]
{
    let userClassification = $user.dataClassification;
    let valueClassificaton = if(
                                $dataMd->keys()->contains($valueKey),
                                | let attrs = $dataMd->get($valueKey)->toOne(); 
                                  if($attrs->keys()->contains('data-classification'), | $attrs->get('data-classification')->toOne(),|0);, 
                                |0);
    let result = $userClassification >= $valueClassificaton;
    let reason = 'Condition : [ User classification = ' + $userClassification->toString() + ' >= ' + ' Data classifcation = ' + $valueClassificaton->toString() + ']';
    if ($result, | ^AuthzResult(result=$result, reason=$reason), | ^AuthzResult(result=$result, reason = 'Failed ' + $reason));
}

function meta::relational::authz::visitValueImpl(valueKey:String[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1], results:meta::relational::authz::AuthzResults[1]):meta::relational::authz::AuthzResults[1]
{
  let authzResult = meta::relational::authz::isAuthorized($valueKey, $user, $dataMd);
  let authzResultPretty = if($authzResult.result, |$authzResult.result->toString(), |'FALSE');
  println('Visiting ' + $valueKey + ' : Authorized = ' + $authzResultPretty + ' : ' + $authzResult.reason);
  
  meta::relational::authz::add($results, $valueKey, $authzResult);
}

function meta::relational::authz::visitPropertyValue(p:PropertyPathNode[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1],results:meta::relational::authz::AuthzResults[1]):meta::relational::authz::AuthzResults[1]
{
  let valueKey = $p.class.name->toOne()+'.'+$p.property.name->toOne();
  meta::relational::authz::visitValueImpl($valueKey, $user, $dataMd, $results);
}


function meta::relational::authz::visitClassValue(c:Class<Any>[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1], results:meta::relational::authz::AuthzResults[1]):meta::relational::authz::AuthzResults[1]
{
  let valueKey = $c.name->toOne();
  meta::relational::authz::visitValueImpl($valueKey, $user, $dataMd, $results);
}

function meta::relational::authz::visitStringValue(value:String[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1], results:meta::relational::authz::AuthzResults[1]):meta::relational::authz::AuthzResults[1]
{
  meta::relational::authz::visitValueImpl($value, $user, $dataMd, $results);
}


function meta::relational::authz::visitImpl(root:PropertyPathTree[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1], results:meta::relational::authz::AuthzResults[1]):meta::relational::authz::AuthzResults[1]
{ 
    let rootResult = $root.value->match(
      [
        c:Class<Any>[1] | meta::relational::authz::visitClassValue($c, $user, $dataMd, $results),
        s:String[1] | meta::relational::authz::visitStringValue($s, $user, $dataMd, $results),
        p:PropertyPathNode[1] | meta::relational::authz::visitPropertyValue($p, $user, $dataMd, $results)
      ]
    );

    let childrenResult = $root.children->sort({a,b| if($a.value->instanceOf(PropertyPathNode) && $b.value->instanceOf(PropertyPathNode),
                             |let c = $a.value->cast(@PropertyPathNode);
                              let d = $b.value->cast(@PropertyPathNode);
                              let e = $c.class.name->toOne()+'.'+$c.property.name->toOne();
                              let f = $d.class.name->toOne()+'.'+$d.property.name->toOne();
                              $e->compare($f);,
                             |0
                          );
                     })
              ->map(c| meta::relational::authz::visitImpl($c, $user, $dataMd, $results));

  meta::relational::authz::merge($rootResult->concatenate($childrenResult));
}

function meta::relational::authz::visit(root:PropertyPathTree[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):meta::relational::authz::AuthzResults[1]
{ 
    let results = meta::relational::authz::newAuthzResults();
    meta::relational::authz::visitImpl($root, $user, $dataMd, $results);
}
