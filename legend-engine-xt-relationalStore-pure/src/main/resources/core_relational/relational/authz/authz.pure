
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::pure::lineage::scanProperties::*;
import meta::pure::lineage::scanRelations::*;
import meta::relational::authz::*;

// TODO - Move to different package or use a different model 
Class meta::relational::authz::User
{
   name: String[1];
   userName: String[1];
   dataClassification: Integer[1];
}

// TODO - Move to different package. Not relational
Class meta::relational::authz::AuthzResult
{
  result:Boolean[1];
  reason:String[1];
}

function meta::relational::authz::isAuthorized(valueKey:String[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):AuthzResult[1]
{
    let userClassification = $user.dataClassification;
    let valueClassificaton = if(
                                $dataMd->keys()->contains($valueKey),
                                | let attrs = $dataMd->get($valueKey)->toOne(); 
                                  if($attrs->keys()->contains('data-classification'), | $attrs->get('data-classification')->toOne(),|0);, 
                                |0);
    let result = $userClassification >= $valueClassificaton;
    let reason = 'Condition : [ User classification = ' + $userClassification->toString() + ' >= ' + ' Data classifcation = ' + $valueClassificaton->toString() + ']';
    if ($result, | ^AuthzResult(result=$result, reason=$reason), | ^AuthzResult(result=$result, reason = 'Failed ' + $reason));
}

function meta::relational::authz::visitValueImpl(valueKey:String[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):Boolean[1]
{
  let authzResult = meta::relational::authz::isAuthorized($valueKey, $user, $dataMd);
  let authzResultPretty = if($authzResult.result, |$authzResult.result->toString(), |'FALSE');
  println('Visiting ' + $valueKey + ' : Authorized = ' + $authzResultPretty + ' : ' + $authzResult.reason);
  $authzResult.result;
}

function meta::relational::authz::visitPropertyValue(p:PropertyPathNode[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):Boolean[1]
{
  let valueKey = $p.class.name->toOne()+'.'+$p.property.name->toOne();
  meta::relational::authz::visitValueImpl($valueKey, $user, $dataMd);
}


function meta::relational::authz::visitClassValue(c:Class<Any>[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):Boolean[1]
{
  let valueKey = $c.name->toOne();
  meta::relational::authz::visitValueImpl($valueKey, $user, $dataMd);
}

function meta::relational::authz::visitStringValue(value:String[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):Boolean[1]
{
  meta::relational::authz::visitValueImpl($value, $user, $dataMd);
}


function meta::relational::authz::visit(root:PropertyPathTree[1], user:User[1], dataMd:Map<String, Map<String, Integer>>[1]):Boolean[1]
{ 
    let rootResult = $root.value->match(
      [
        c:Class<Any>[1] | meta::relational::authz::visitClassValue($c, $user, $dataMd),
        s:String[1] | meta::relational::authz::visitStringValue($s, $user, $dataMd),
        p:PropertyPathNode[1] | meta::relational::authz::visitPropertyValue($p, $user, $dataMd)
      ]
    );

    let childrenResult = $root.children->sort({a,b| if($a.value->instanceOf(PropertyPathNode) && $b.value->instanceOf(PropertyPathNode),
                             |let c = $a.value->cast(@PropertyPathNode);
                              let d = $b.value->cast(@PropertyPathNode);
                              let e = $c.class.name->toOne()+'.'+$c.property.name->toOne();
                              let f = $d.class.name->toOne()+'.'+$d.property.name->toOne();
                              $e->compare($f);,
                             |0
                          );
                     })
              ->map(c| meta::relational::authz::visit($c, $user, $dataMd));

  $rootResult && !$childrenResult->contains(false);
  
}
