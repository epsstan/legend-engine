
import meta::pure::functions::collection::*;

function meta::relational::authz::test::evalAuthzForUser(
      user:meta::relational::authz::User[1], 
      dataMd:Map<String, Map<String, Integer>>[1],
      scanDetails:meta::pure::lineage::scanRelations::ScanDetails[1]
):meta::relational::authz::AuthzResults[1]
{
  println('+ Authz tree for user = ' + $user.userName);
  let result = meta::relational::authz::visit($scanDetails.propertyTree, $user, $dataMd);
  println('+ Authz result = ' + $result->toString());
  $result;
}

function meta::relational::authz::test::buildDataMetadata():Map<String, Map<String, Integer>>[1]
{
  newMap(
    [
      pair('Person', newMap([pair('data-classification', 1)])),
      pair('Person.firstName', newMap([pair('data-classification', 2)])),
      pair('Person.lastName', newMap([pair('data-classification', 2)])),
      pair('Person.age', newMap([pair('data-classification', 6)]))
    ]
  );
}

function meta::relational::authz::test::testCase1():Any[1]
{
  // Alice does not have authz over the full tree
  let alice = ^meta::relational::authz::User(name='alice', userName='alice', dataClassification=1);
  let aliceResults = meta::relational::authz::test::evalAuthzForUser($alice, meta::relational::authz::test::buildDataMetadata(), meta::pure::lineage::scanRelations::test::query1());
  //println(meta::relational::authz::printAsString($aliceResults));
  assertFalse($aliceResults.aggregate);
  assertEq($aliceResults.results->get('Firm')->toOne().reason, 'Condition : [ User classification = 1 >=  Data classifcation = 0]');
  assertEq($aliceResults.results->get('Firm.legalName')->toOne().reason, 'Condition : [ User classification = 1 >=  Data classifcation = 0]');
  assertEq($aliceResults.results->get('Firm.employees')->toOne().reason, 'Condition : [ User classification = 1 >=  Data classifcation = 0]');
  assertEq($aliceResults.results->get('Firm.employees')->toOne().reason, 'Condition : [ User classification = 1 >=  Data classifcation = 0]');
  assertEq($aliceResults.results->get('Person.firstName')->toOne().reason, 'Failed Condition : [ User classification = 1 >=  Data classifcation = 2]');
  assertEq($aliceResults.results->get('Person.lastName')->toOne().reason, 'Failed Condition : [ User classification = 1 >=  Data classifcation = 2]');
  assertEq($aliceResults.results->get('Person.age')->toOne().reason, 'Failed Condition : [ User classification = 1 >=  Data classifcation = 6]');

  // Charlie has authz over the full tree
  let charlie = ^meta::relational::authz::User(name='charlie', userName='charlie', dataClassification=7);
  let charlieResults = meta::relational::authz::test::evalAuthzForUser($charlie, meta::relational::authz::test::buildDataMetadata(), meta::pure::lineage::scanRelations::test::query1());
  //println(meta::relational::authz::printAsString($charlieResults));
  assert($charlieResults.aggregate);
  assertEq($charlieResults.results->get('Firm')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 0]');
  assertEq($charlieResults.results->get('Firm.legalName')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 0]');
  assertEq($charlieResults.results->get('Firm.employees')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 0]');
  assertEq($charlieResults.results->get('Firm.employees')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 0]');
  assertEq($charlieResults.results->get('Person.firstName')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 2]');
  assertEq($charlieResults.results->get('Person.lastName')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 2]');
  assertEq($charlieResults.results->get('Person.age')->toOne().reason, 'Condition : [ User classification = 7 >=  Data classifcation = 6]');
  1;
}



